# Default values for nginx.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
# This will set the replicaset count more information can be found here: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/

replicaCount: 1

createNamespace: false
namespace: monitoring
# This sets the container image more information can be found here: https://kubernetes.io/docs/concepts/containers/images/
init:
  name: init-mycontainer
  image: busybox
  tag: "1.37"
  command: wget https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ -O /monitoring/index.html; mkdir -p /monitoring/conf
  volumeMounts:
    - name: monitoring-vol
      mountPath: /monitoring
image:
  repository: nginx  
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "custom"

container:
  port: 8000
  serverName: "_"
  rootPath: /monitoring
  lifecycle:
      - sh
      - -c
      - rm -rf /monitoring/index.html

persistence:
  enabled: true
  name: pv-claim
  namespace: monitoring
  storageClassName: custom-class
  accessMode: ReadWriteOnce
  size: 1Gi

clusterRoleBindings:
  - name: bind-cd-metrics
    namespace: monitoring
    roleName: admin
    subjects:
      - kind: ServiceAccount
        name: cd
        namespace: monitoring

  - name: bind-monitoring-metrics
    roleName: endpoints-reader
    subjects:
      - kind: ServiceAccount
        name: monitoring
        namespace: monitoring

storageclass:
  name: custom-class
  annotations:
    storageclass.kubernetes.io/is-default-class: "false"
  provisioner: k8s.io/minikube-hostpath
  reclaimPolicy: Retain

role-admin:
  name: admin

role-metrics:
  name: endpoints-reader

# This is for the secrets for pulling an image from a private repository more information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# This is to override the chart name.
nameOverride: ""
fullnameOverride: ""

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1

configmap:
  name: app-config

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount_cd:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: "cd"

serviceAccount_monitoring:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: "monitoring"

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {app: nginx}



podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  name: service-pod
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # This sets the ports more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#field-spec-ports
  port: 8000
  targetPort: 8000


# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  class: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/use-regex: "true"
  host: "monitoring.otus"
  paths:
    - path: /homepage(/|$)(.*)
      pathType: ImplementationSpecific
      serviceName: service-pod
      servicePort: 8000
    - path: /
      pathType: Prefix
      serviceName: service-pod
      servicePort: 8000
# -- Expose the service via gateway-api HTTPRoute
# Requires Gateway API resources and suitable controller installed within the cluster
# (see: https://gateway-api.sigs.k8s.io/guides/)
httpRoute:
  # HTTPRoute enabled.
  enabled: false

resources: {}
livenessProbe: {}
#  httpGet:
#    path: /
#    port: http
readinessProbe:
  httpGet:
    path: /index.html
    port: 8000
  initialDelaySeconds: 5
  periodSeconds: 10

# Additional volumes on the output Deployment definition.
volumes:
  - name: nginx-conf
    configMap:
      name: app-config
      items:
        - key: nginx.conf
          path: nginx.conf
  - name: monitoring-vol
    persistentVolumeClaim:
      claimName: pv-claim
  - name: monitoring-config
    configMap:
      name: app-config
      items: 
        - key: file
          path: file
# Additional volumeMounts on the output Deployment definition.
volumeMounts: 
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true
  - name: nginx-conf
    mountPath: /opt/nginx/conf/nginx.conf
    subPath: nginx.conf
    readOnly: true
  - name: monitoring-vol
    mountPath: /monitoring
  - name: monitoring-config
    mountPath: /monitoring/conf

nodeSelector: {monitoring: "true"}

tolerations: []

affinity: {}
